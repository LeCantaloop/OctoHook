namespace OctoHook
{
    using Octokit;
    using Octokit.Events;
    using System;
    using System.Text.RegularExpressions;
    using System.Linq;
    using System.Collections.ObjectModel;
    using OctoHook.CommonComposition;
    using System.Threading.Tasks;
    using OctoHook.Diagnostics;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Reflection;
    using OctoHook.Properties;

    [Component]
    public class AutoTask : IOctoJob<IssuesEvent>
    {
        internal static readonly string header = Strings.FormatHeader(ThisAssembly.InformationalVersion,
            Strings.Note, Strings.Wiki, Strings.Title);

		static readonly string taskLinkFormat = @"-\s\[(\s|x|X)\]\s{0}.+$";

        static readonly ITracer tracer = Tracer.Get<AutoTask>();

		static readonly Regex headerExpr = new Regex(@"<!-- This section was generated by OctoHook v[^\s]+ -->", RegexOptions.Compiled);
        static readonly Regex issueLinkExpr = new Regex(@"(?<task>-\s\[(\s|x|X)\]\s)?((?<owner>\w+)/(?<repo>\w+))?#(?<number>\d+)", RegexOptions.Compiled | RegexOptions.ExplicitCapture);
        static readonly Regex autoTaskExpr = new Regex(@"-\s\[(\s|x|X)\]\s(\w+/\w+)?\#\d+.+$", RegexOptions.Compiled | RegexOptions.ExplicitCapture);

        private IGitHubClient github;

        public AutoTask(IGitHubClient github)
        {
            this.github = github;
        }

        public async Task ProcessAsync(IssuesEvent @event)
        {
            var issue = @event.Issue;

            foreach (var link in issueLinkExpr.Matches(issue.Body)
                .OfType<Match>()
                // Skip the links that are incoming links from a task list 
                // themselves (like the ones we generate!)
                .Where(m => m.Success && !m.Groups["task"].Success)
                .Select(m => new
                {
                    // We support cross-repo links too, see https://github.com/blog/967-github-secrets
                    Owner = string.IsNullOrEmpty(m.Groups["owner"].Value) ? @event.Repository.Owner.Login : m.Groups["owner"].Value,
                    Repo = string.IsNullOrEmpty(m.Groups["repo"].Value) ? @event.Repository.Name : m.Groups["repo"].Value,
                    Number = int.Parse(m.Groups["number"].Value),
                }))
            {
                try
                {
                    tracer.Verbose(Strings.Trace.FoundLinkInBody(
                        link.Owner, link.Repo, link.Number,
                        @event.Repository.Owner.Login, @event.Repository.Name, @event.Issue.Number));

                    var linked = await github.Issue.Get(link.Owner, link.Repo, link.Number);
                    // Simplifies code later.
                    if (linked.Body == null)
                        linked.Body = "";

                    // If the repos don't match, then the foreign link to our issue would need to 
                    // be a cross-repo link instead.
                    var expectedLink =
                        (link.Owner != @event.Repository.Owner.Login ||
                        link.Repo != @event.Repository.Name) ?
                        @event.Repository.Owner.Login + "/" + @event.Repository.Name + "#" + @event.Issue.Number :
                        // Otherwise, it will be a simple link
                        "#" + @event.Issue.Number;

                    var taskLink = Strings.FormatTask(@event.Issue.State == ItemState.Closed ? "x" : " ", expectedLink, @event.Issue.Title).Trim();
                    var taskLinkRegex = new Regex(string.Format(CultureInfo.InvariantCulture, taskLinkFormat, expectedLink), RegexOptions.Multiline);

                    var existingMatch = taskLinkRegex.Match(linked.Body);
                    if (existingMatch.Success && existingMatch.Value.Trim() == taskLink)
                        return;

                    var newBody = taskLinkRegex.Replace(linked.Body, taskLink);

                    // If the new body isn't different, we haven't found an existing link, so we need to add 
                    // our header (if non-existent) and the task link.
                    if (linked.Body == newBody)
                    {
						// Find the last existing task link, if any, so we can append our link at the end
						var lastTask = autoTaskExpr.Matches(newBody).OfType<Match>().LastOrDefault();
						if (lastTask != null)
						{
							newBody = newBody.Insert(lastTask.Index + lastTask.Length,
								Environment.NewLine + taskLink);
                            tracer.Info(Strings.Trace.InsertedLinkInExistingList(taskLink));
						}
						else
						{
							// Otherwise, there's no existing task list.
							// If there is existing content, we want to append 
							// our list an extra newline below that.
							if (newBody.Length > 0)
								newBody += Environment.NewLine;

							newBody = newBody.Insert(newBody.Length, header + taskLink);
                            tracer.Info(Strings.Trace.AddedLinkInNewList(taskLink));
						}
                    }
                    else
                    {
                        tracer.Info(Strings.Trace.UpdatedExistingLink(taskLink));
                    }

                    var update = new IssueUpdate { Body = newBody, State = linked.State };

                    // If we don't preserve these properties, 
                    // they get reset :S
                    if (linked.Assignee != null)
                        update.Assignee = linked.Assignee.Login;
                    if (linked.Milestone != null)
                        update.Milestone = linked.Milestone.Number;
                    if (linked.Labels != null)
                        update.Labels = linked.Labels.Select(l => l.Name).ToList();

                    // Finally, update the referenced task body.
                    await github.Issue.Update(link.Owner, link.Repo, link.Number, update);
                }
                catch (NotFoundException)
                {
                    // It may be a link to a bug/issue in another system.
                }
                catch (Exception ex)
                {
                    tracer.Error(ex, "Failed to process issue: " + ex.Message);
                    throw;
                }
            }
        }
    }
}
